
# 题目

已知一个长度为 `n` 的数组，预先按照升序排列，经由 `1` 到 `n` 次 __旋转__ 后，得到输入数组。例如，原数组 `nums = [0,1,2,4,5,6,7]` 在变化后可能得到：若旋转 `4` 次，则可以得到 `[4,5,6,7,0,1,2]` ; 若旋转 `7` 次，则可以得到 `[0,1,2,4,5,6,7]`  

给你一个元素值 __互不相同__ 的数组 `nums` ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 __最小元素__  
你必须设计一个时间复杂度为 __O(log n)__ 的算法解决此问题。

# 样例

## 样例01

输入：`nums = [3,4,5,1,2]`  
输出：`1`

## 样例02

输入：`nums = [101]`  
输出：`101`

# 心路历程
  
明确看到题目要求使用 __O(log n)__ 的算法后，我才意识到可以使用二分来做这道题。  

不过即使知道了要用二分也想了很久 (__二分中, 最重要的是想清楚: 要依据什么判断来抛弃中点左边或右边的全部数组元素__)

```python
class Solution:
    def findMin(self, nums: List[int]) -> int:
        left, right = 0, len(nums)-1
        while left <= right:
            mid = (left+right)//2
            if nums[mid] < nums[0]:
                right = mid - 1
            elif nums[mid] >= nums[0]:
                left = mid + 1
        return nums[right+1] if right != len(nums)-1 else nums[0]
```

# 事后复盘

__所有可以使用二分查找来做的题目，本质上应该都可以用BF来写__。但是正是因为题目中多给出了一个性质、条件，例如本题目中给出的数组为 __「旋转排序数组」__，亦或是最常见的 __「升序数组」__，才使得可以有二分查找这种更优的解法。

换句话说，如果题目多给了一个条件，但使用BF写完却完全没用到这个条件，此时作为一个题目，它一定有更好的解法，必须长考，换个解法

20250123repo: 总结得非常非常好 😍
